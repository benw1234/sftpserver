#include "sftpserver.h"
#include "alloc.h"
#include "users.h"
#include "debug.h"
#include "sftp.h"
#include "handle.h"
#include "send.h"
#include "parse.h"
#include "types.h"
#include "globals.h"
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stdio.h>
#include <unistd.h>
#include <time.h>
#include <sys/stat.h>

/* Callbacks */

/* Send an SSH_FXP_STATUS.  We just limit the status values to those known to
 * v3 clients and call the generic routine. */
void v3_status(struct sftpjob *job,
               uint32_t status,
               const char *msg) {
  if(status > SSH_FX_OP_UNSUPPORTED)
    /* Launder out statuses that don't exist in v3 */
    generic_status(job, SSH_FX_FAILURE, status, msg);
  else
    generic_status(job, status, status, msg);
}

/* Encode/decode path names.  v3 does not know what encoding filenames use.  We
 * assume that the client and the server use the same encoding and so don't
 * perform any translation. */
void v3_encode(struct sftpjob attribute((unused)) *job,
               char attribute((unused)) **path) {
}

int v3_decode(struct sftpjob attribute((unused)) *job, 
              char attribute((unused)) **path) {
  return 0;
}

/* Send a filename list as found in an SSH_FXP_NAME response.  The response
 * header and so on must be generated by the caller. */
void v3_sendnames(struct sftpjob *job, 
                  int nnames, const struct namedata *names) {
  char perms[64], linkcount[64], size[64], *p, date[64];
  char *longname;
  const char *user, *group;
  time_t now;
  struct tm mtime, nowtime;

  /* We'd like to know what year we're in for dates in longname */
  time(&now);
  gmtime_r(&now, &nowtime);
  send_uint32(job, nnames);
  while(nnames > 0) {
    send_path(job, names->path);
    if(!names->dummy) {
      /* v3 has a 'longname' field containing a textual represenation of the
       * file details.  Subsequent versions don't have it, considering that it
       * is the responsibility of the client to format this stuff in some
       * manner sensible for local consumption.
       *
       * We write the details out longhand, there not being quite enough
       * commonality to justify tables.
       */
      p = perms;
      switch(names->filestat.st_mode & S_IFMT) {
      case S_IFIFO: *p++ = 'p'; break;
      case S_IFCHR: *p++ = 'c'; break;
      case S_IFDIR: *p++ = 'd'; break;
      case S_IFBLK: *p++ = 'b'; break;
      case S_IFREG: *p++ = '-'; break;
      case S_IFLNK: *p++ = 'l'; break;
      case S_IFSOCK: *p++ = 's'; break;
      default: *p++ = '?'; break;
      }
      *p++ = (names->filestat.st_mode & 00400) ? 'r' : '-';
      *p++ = (names->filestat.st_mode & 00200) ? 'w' : '-';
      switch(names->filestat.st_mode & 04100) {
      case 00000: *p++ = '-'; break;
      case 00100: *p++ = 'x'; break;
      case 04000: *p++ = 'S'; break;
      case 04100: *p++ = 's'; break;
      }
      *p++ = (names->filestat.st_mode & 00040) ? 'r' : '-';
      *p++ = (names->filestat.st_mode & 00020) ? 'w' : '-';
      switch(names->filestat.st_mode & 02010) {
      case 00000: *p++ = '-'; break;
      case 00010: *p++ = 'x'; break;
      case 02000: *p++ = 'S'; break;
      case 02010: *p++ = 's'; break;
      }
      *p++ = (names->filestat.st_mode & 00004) ? 'r' : '-';
      *p++ = (names->filestat.st_mode & 00002) ? 'w' : '-';
      switch(names->filestat.st_mode & 02001) {
      case 00000: *p++ = '-'; break;
      case 00001: *p++ = 'x'; break;
      case 01000: *p++ = 'T'; break;
      case 01001: *p++ = 't'; break;
      }
      *p = 0;
      sprintf(linkcount, "%ju", (uintmax_t)names->filestat.st_nlink);
      sprintf(size, "%ju", (uintmax_t)names->filestat.st_size);
      user = uid2name(job->a, names->filestat.st_uid);
      group = gid2name(job->a, names->filestat.st_gid);
      gmtime_r(&names->filestat.st_mtime, &mtime);
      /* Timestamps in the current year we give down to seconds.  For
       * timestamps in other years we give the year. */
      if(mtime.tm_year == nowtime.tm_year)
        strftime(date, sizeof date, "%b %d %H:%M", &mtime);
      else
        strftime(date, sizeof date, "%b %d  %Y", &mtime);
      longname = alloc(job->a, 80 + strlen(names->path));
      /* The draft is pretty specific about field widths */
      sprintf(longname, "%10.10s %3.3s %-8.8s %-8.8s %8.8s %12.12s %s",
              perms, linkcount, user, group, size, date, names->path);
      send_string(job, longname);
    } else
      /* If we're sending dummy attributes then there's no point in a
       * longname */
      send_string(job, "");
    protocol->sendattrs(job, &names->filestat, names->dummy);
    ++names;
    --nnames;
  }
}

void v3_sendattrs(struct sftpjob *job,
                  const struct stat *filestat,
                  int dummy) {
  if(!dummy) {
    send_uint32(job,
                SSH_FILEXFER_ATTR_SIZE
                |SSH_FILEXFER_ATTR_UIDGID
                |SSH_FILEXFER_ATTR_PERMISSIONS
                |SSH_FILEXFER_ATTR_ACMODTIME);
    send_uint64(job, filestat->st_size);
    send_uint32(job, filestat->st_uid);
    send_uint32(job, filestat->st_gid);
    send_uint32(job, filestat->st_mode);
    send_uint32(job, filestat->st_atime);
    send_uint32(job, filestat->st_mtime);
  } else
    /* Dummy attributes are almost certainly inaccurate, so we avoid lying */
    send_uint32(job, 0);
}

/* Command implementations */

void sftp_already_init(struct sftpjob *job) {
  /* Cannot initialize more than once */
  protocol->status(job, SSH_FX_FAILURE, "already initialized");
}

void sftp_remove(struct sftpjob *job) {
  char *path;
  
  pcheck(parse_path(job, &path));
  if(unlink(path) < 0) send_errno_status(job);
  else send_ok(job);
}

void sftp_rmdir(struct sftpjob *job) {
  char *path;
  
  pcheck(parse_path(job, &path));
  if(rmdir(path) < 0) send_errno_status(job);
  else send_ok(job);
}

void sftp_v3_rename(struct sftpjob *job) {
  char *oldpath, *newpath;

  pcheck(parse_path(job, &oldpath));
  pcheck(parse_path(job, &newpath));
  /* newpath is not allowed to exist.  We enforce this atomically by attempting
     to link() from oldpath to newpath and unlinking oldpath if it succeeds. */
  if(link(oldpath, newpath) < 0) {
    if(errno != EEXIST) {
      /* newpath does not exist but something stopped us renaming.  Two
       * important cases are where oldpath is a directory, which link() cannot
       * support but the v3/v4 drafts say we should, or where both paths are on
       * a filesystem incapable of hard links.
       *
       * We give up on atomicity for such cases (v3/v4 drafts do not state a
       * requirement for it) and have other useful semantics instead.
       *
       * This has the slightly odd effect of giving rename(2) semantics only
       * for directories and on primitive filesystems.  If you want such
       * semantics reliably you need SFTP v5 or better.
       */
      if(rename(oldpath, newpath) < 0)
        send_errno_status(job);
      else
        send_ok(job);
    } else
      send_errno_status(job);
  } else if(unlink(oldpath) < 0) {
    send_errno_status(job);
    unlink(newpath);
  } else
    send_ok(job);
}

void sftp_symlink(struct sftpjob *job) {
  char *oldpath, *newpath;

  pcheck(parse_path(job, &oldpath));
  pcheck(parse_path(job, &newpath));
  if(symlink(oldpath, newpath) < 0) send_errno_status(job);
  else send_ok(job);
  /* v3-v5 don't specify what happens if the target exists.  We take whatever
   * the OS gives us. */
}

void sftp_readlink(struct sftpjob *job) {
  char *path;
  char *result;
  int n;
  size_t nresult;
  struct namedata nd;

  pcheck(parse_path(job, &path));
  /* readlink(2) has a rather stupid interface */
  nresult = 256;
  while(nresult > 0 && nresult <= 65536) {
    result = alloc(job->a, nresult);
    n = readlink(path, result, nresult);
    if(n < 0) {
      send_errno_status(job);
      return;
    }
    if((unsigned)n < nresult) {
      /* 1-element name list */
      path[n] = 0;
      memset(&nd, 0, sizeof nd);
      nd.path = path;
      nd.dummy = 1;
      send_begin(job);
      send_uint8(job, SSH_FXP_NAME);
      send_uint32(job, job->id);
      protocol->sendnames(job, 1, &nd);
      send_end(job);
      return;
    }
    nresult *= 2;
  }
  /* We should have wasted at most about 128Kbyte if we get here */
  protocol->status(job, SSH_FX_FAILURE, "link name is too long");
}

void sftp_opendir(struct sftpjob *job) {
  char *path;
  DIR *dp;
  struct handleid id;

  pcheck(parse_path(job, &path));
  if(!(dp = opendir(path))) {
    send_errno_status(job);
    return;
  }
  handle_new_dir(&id, dp, path);
  send_begin(job);
  send_uint8(job, SSH_FXP_HANDLE);
  send_uint32(job, job->id);
  send_handle(job, &id);
  send_end(job);
}

void sftp_readdir(struct sftpjob *job) {
  struct handleid id;
  DIR *dp;
  uint32_t rc;
  struct namedata d[MAXNAMES];
  int n;
  struct dirent *de;
  const char *path;
  char *fullpath;
  
  pcheck(parse_handle(job, &id));
  if((rc = handle_get_dir(&id, &dp, &path)))
    protocol->status(job, rc, "invalid directory handle");
  memset(d, 0, sizeof d);
  for(n = 0; n < MAXNAMES;) {
    /* readdir() has a slightly shonky interface - a null return can mean EOF
     * or error, and there is no guarantee that errno is reset to 0 on EOF. */
    errno = 0;
    de = readdir(dp);
    if(!de)
      break;
    /* We include . and .. in the list - if the cliient doesn't like them it
     * can filter them out itself. */
    d[n].path = strcpy(alloc(job->a, strlen(de->d_name) + 1), de->d_name);
    /* We need the full path to be able to stat the file */
    fullpath = alloc(job->a, strlen(path) + strlen(d[n].path) + 2);
    strcpy(fullpath, path);
    strcat(fullpath, "/");
    strcat(fullpath, d[n].path);
    if(lstat(fullpath, &d[n].filestat)) {
      send_errno_status(job);
      return;
    }
    ++n;
  }
  
  if(errno) {
    send_errno_status(job);
    return;
  }
  if(n) {
    send_begin(job);
    send_uint8(job, SSH_FXP_NAME);
    send_uint32(job, job->id);
    protocol->sendnames(job, n, d);
    send_end(job);
  } else
    protocol->status(job, SSH_FX_EOF, "end of directory list");
}

void sftp_close(struct sftpjob *job) {
  struct handleid id;
  
  pcheck(parse_handle(job, &id));
  protocol->status(job, handle_close(&id), "closing handle");
}

void sftp_v3_realpath(struct sftpjob *job) {
  char *path;
  struct namedata nd;

  pcheck(parse_path(job, &path));
  memset(&nd, 0, sizeof nd);
  /* realpath() demands a buffer of PATH_MAX bytes.  PATH_MAX isn't actually
   * guaranteed to be a constant so we must allocate in dynamically.  We add a
   * bit of extra space as a guard against broken C libraries. */
  nd.path = alloc(job->a, PATH_MAX + 64);
  nd.dummy = 1;
  if(realpath(path, nd.path)) {
    send_begin(job);
    send_uint8(job, SSH_FXP_NAME);
    send_uint32(job, job->id);
    protocol->sendnames(job, 1, &nd);
    send_end(job);
  } else
    send_errno_status(job);
}

/* Command code for the various _*STAT calls.  rc is the return value
 * from *stat() and SB is the buffer. */
static void sftp_v3_stat_core(struct sftpjob *job, int rc, 
                              const struct stat *sb) {
  if(!rc) {
    send_begin(job);
    send_uint8(job, SSH_FXP_ATTRS);
    send_uint32(job, job->id);
    protocol->sendattrs(job, sb, 0);
    send_end(job);
  } else
    send_errno_status(job);
}

void sftp_v3_lstat(struct sftpjob *job) {
  char *path;
  struct stat sb;

  pcheck(parse_path(job, &path));
  sftp_v3_stat_core(job, lstat(path, &sb), &sb);
}

void sftp_v3_stat(struct sftpjob *job) {
  char *path;
  struct stat sb;

  pcheck(parse_path(job, &path));
  sftp_v3_stat_core(job, stat(path, &sb), &sb);
}

static const struct sftpcmd sftpv3tab[] = {
  { SSH_FXP_INIT, sftp_already_init },
  //{ SSH_FXP_OPEN, sftp_v3_open },
  { SSH_FXP_CLOSE, sftp_close },
  //{ SSH_FXP_READ, sftp_read },
  //{ SSH_FXP_WRITE, sftp_write },
  { SSH_FXP_LSTAT, sftp_v3_lstat },
  //{ SSH_FXP_FSTAT, sftp_v3_fstat },
  //{ SSH_FXP_SETSTAT, sftp_setstat },
  //{ SSH_FXP_FSETSTAT, sftp_fsetstat },
  { SSH_FXP_OPENDIR, sftp_opendir },
  { SSH_FXP_READDIR, sftp_readdir },
  { SSH_FXP_REMOVE, sftp_remove },
  //{ SSH_FXP_MKDIR, sftp_mkdir },
  //{ SSH_FXP_RMDIR, sftp_rmdir },
  { SSH_FXP_REALPATH, sftp_v3_realpath },
  { SSH_FXP_STAT, sftp_v3_stat },
  { SSH_FXP_RENAME, sftp_v3_rename },
  { SSH_FXP_READLINK, sftp_readlink },
  //{ SSH_FXP_SYMLINK, sftp_symlink },
  //{ SSH_FXP_EXTENDED, sftp_extended },
};

const struct sftpprotocol sftpv3 = {
  sizeof sftpv3tab / sizeof (struct sftpcmd),
  sftpv3tab,
  v3_status,
  v3_sendnames,
  v3_sendattrs,
  v3_encode,
  v3_decode
};

/*
Local Variables:
c-basic-offset:2
comment-column:40
fill-column:79
indent-tabs-mode:nil
End:
*/
