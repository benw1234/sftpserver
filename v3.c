#include "sftpserver.h"
#include "alloc.h"
#include "users.h"
#include "debug.h"
#include "sftp.h"
#include "handle.h"
#include "send.h"
#include "parse.h"
#include "types.h"
#include "globals.h"
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include <sys/stat.h>
#include <inttypes.h>

/* Callbacks */

/* Send an SSH_FXP_STATUS.  We just limit the status values to those known to
 * v3 clients and call the generic routine. */
void v3_status(struct sftpjob *job,
               uint32_t status,
               const char *msg) {
  if(status > SSH_FX_OP_UNSUPPORTED && status != (uint32_t)-1)
    /* Launder out statuses that don't exist in v3 */
    generic_status(job, SSH_FX_FAILURE, status, msg);
  else
    generic_status(job, status, status, msg);
}

/* Encode/decode path names.  v3 does not know what encoding filenames use.  We
 * assume that the client and the server use the same encoding and so don't
 * perform any translation. */
void v3_encode(struct sftpjob attribute((unused)) *job,
               char attribute((unused)) **path) {
}

int v3_decode(struct sftpjob attribute((unused)) *job, 
              char attribute((unused)) **path) {
  return 0;
}

/* Send a filename list as found in an SSH_FXP_NAME response.  The response
 * header and so on must be generated by the caller. */
void v3_sendnames(struct sftpjob *job, 
                  int nnames, const struct namedata *names) {
  char perms[64], linkcount[64], size[64], *p, date[64];
  char *longname;
  const char *user, *group;
  time_t now;
  struct tm mtime, nowtime;

  /* We'd like to know what year we're in for dates in longname */
  time(&now);
  gmtime_r(&now, &nowtime);
  send_uint32(job, nnames);
  while(nnames > 0) {
    send_path(job, names->path);
    if(!names->dummy) {
      /* v3 has a 'longname' field containing a textual represenation of the
       * file details.  Subsequent versions don't have it, considering that it
       * is the responsibility of the client to format this stuff in some
       * manner sensible for local consumption.
       *
       * We write the details out longhand, there not being quite enough
       * commonality to justify tables.
       */
      p = perms;
      switch(names->filestat.st_mode & S_IFMT) {
      case S_IFIFO: *p++ = 'p'; break;
      case S_IFCHR: *p++ = 'c'; break;
      case S_IFDIR: *p++ = 'd'; break;
      case S_IFBLK: *p++ = 'b'; break;
      case S_IFREG: *p++ = '-'; break;
      case S_IFLNK: *p++ = 'l'; break;
      case S_IFSOCK: *p++ = 's'; break;
      default: *p++ = '?'; break;
      }
      *p++ = (names->filestat.st_mode & 00400) ? 'r' : '-';
      *p++ = (names->filestat.st_mode & 00200) ? 'w' : '-';
      switch(names->filestat.st_mode & 04100) {
      case 00000: *p++ = '-'; break;
      case 00100: *p++ = 'x'; break;
      case 04000: *p++ = 'S'; break;
      case 04100: *p++ = 's'; break;
      }
      *p++ = (names->filestat.st_mode & 00040) ? 'r' : '-';
      *p++ = (names->filestat.st_mode & 00020) ? 'w' : '-';
      switch(names->filestat.st_mode & 02010) {
      case 00000: *p++ = '-'; break;
      case 00010: *p++ = 'x'; break;
      case 02000: *p++ = 'S'; break;
      case 02010: *p++ = 's'; break;
      }
      *p++ = (names->filestat.st_mode & 00004) ? 'r' : '-';
      *p++ = (names->filestat.st_mode & 00002) ? 'w' : '-';
      switch(names->filestat.st_mode & 02001) {
      case 00000: *p++ = '-'; break;
      case 00001: *p++ = 'x'; break;
      case 01000: *p++ = 'T'; break;
      case 01001: *p++ = 't'; break;
      }
      *p = 0;
      sprintf(linkcount, "%ju", (uintmax_t)names->filestat.st_nlink);
      sprintf(size, "%ju", (uintmax_t)names->filestat.st_size);
      user = uid2name(job->a, names->filestat.st_uid);
      group = gid2name(job->a, names->filestat.st_gid);
      gmtime_r(&names->filestat.st_mtime, &mtime);
      /* Timestamps in the current year we give down to seconds.  For
       * timestamps in other years we give the year. */
      if(mtime.tm_year == nowtime.tm_year)
        strftime(date, sizeof date, "%b %d %H:%M", &mtime);
      else
        strftime(date, sizeof date, "%b %d  %Y", &mtime);
      longname = alloc(job->a, 80 + strlen(names->path));
      /* The draft is pretty specific about field widths */
      sprintf(longname, "%10.10s %3.3s %-8.8s %-8.8s %8.8s %12.12s %s",
              perms, linkcount, user, group, size, date, names->path);
      send_string(job, longname);
    } else
      /* If we're sending dummy attributes then there's no point in a
       * longname */
      send_string(job, "");
    protocol->sendattrs(job, &names->filestat, names->dummy);
    ++names;
    --nnames;
  }
}

void v3_sendattrs(struct sftpjob *job,
                  const struct stat *filestat,
                  int dummy) {
  if(!dummy) {
    send_uint32(job,
                SSH_FILEXFER_ATTR_SIZE
                |SSH_FILEXFER_ATTR_UIDGID
                |SSH_FILEXFER_ATTR_PERMISSIONS
                |SSH_FILEXFER_ACMODTIME);
    send_uint64(job, filestat->st_size);
    send_uint32(job, filestat->st_uid);
    send_uint32(job, filestat->st_gid);
    send_uint32(job, filestat->st_mode);
    send_uint32(job, filestat->st_atime);
    send_uint32(job, filestat->st_mtime);
  } else
    /* Dummy attributes are almost certainly inaccurate, so we avoid lying */
    send_uint32(job, 0);
}

int v3_parseattrs(struct sftpjob *job, struct stat *filestat,
                  unsigned long *bits) {
  uint32_t attrbits, n;
  uint64_t size;

  *bits = 0;
  memset(filestat, 0, sizeof filestat);
  if(parse_uint32(job, &attrbits)) return -1;
  if(attrbits & SSH_FILEXFER_ATTR_SIZE) {
    if(parse_uint64(job, &size)) return -1;
    filestat->st_size = (off_t)size;
    if((uint64_t)filestat->st_size != size)
      return -1;
    *bits |= ATTR_SIZE;
  }
  if(attrbits & SSH_FILEXFER_ATTR_UIDGID) {
    if(parse_uint32(job, &n)) return -1;
    filestat->st_uid = n;
    if(parse_uint32(job, &n)) return -1;
    filestat->st_gid = n;
    *bits |= ATTR_UID|ATTR_GID;
  }
  if(attrbits & SSH_FILEXFER_ATTR_PERMISSIONS) {
    if(parse_uint32(job, &n)) return -1;
    filestat->st_mode = n;
    *bits |= ATTR_PERMISSIONS;
  }
  if(attrbits & SSH_FILEXFER_ACMODTIME) {
    if(parse_uint32(job, &n)) return -1;
    filestat->st_atime = n;
    if(parse_uint32(job, &n)) return -1;
    filestat->st_mtime = n;
    *bits |= ATTR_MTIME|ATTR_ATIME;
  }
  if(attrbits & SSH_FILEXFER_ATTR_EXTENDED) {
    if(parse_uint32(job, &n)) return -1;
    while(n-- > 0) {
      parse_string(job, 0, 0);
      parse_string(job, 0, 0);
    }
  }
  return 0;
}

/* Command implementations */

void sftp_already_init(struct sftpjob *job) {
  /* Cannot initialize more than once */
  protocol->status(job, SSH_FX_FAILURE, "already initialized");
}

void sftp_remove(struct sftpjob *job) {
  char *path;
  
  pcheck(parse_path(job, &path));
  D(("sftp_remove %s", path));
  if(unlink(path) < 0) send_errno_status(job);
  else send_ok(job);
}

void sftp_rmdir(struct sftpjob *job) {
  char *path;
  
  pcheck(parse_path(job, &path));
  D(("sftp_rmdir %s", path));
  if(rmdir(path) < 0) send_errno_status(job);
  else send_ok(job);
}

void sftp_v3_rename(struct sftpjob *job) {
  char *oldpath, *newpath;

  pcheck(parse_path(job, &oldpath));
  pcheck(parse_path(job, &newpath));
  D(("sftp_v3_rename %s %s", oldpath, newpath));
  /* newpath is not allowed to exist.  We enforce this atomically by attempting
     to link() from oldpath to newpath and unlinking oldpath if it succeeds. */
  if(link(oldpath, newpath) < 0) {
    if(errno != EEXIST) {
      /* newpath does not exist but something stopped us renaming.  Two
       * important cases are where oldpath is a directory, which link() cannot
       * support but the v3/v4 drafts say we should, or where both paths are on
       * a filesystem incapable of hard links.
       *
       * We give up on atomicity for such cases (v3/v4 drafts do not state a
       * requirement for it) and have other useful semantics instead.
       *
       * This has the slightly odd effect of giving rename(2) semantics only
       * for directories and on primitive filesystems.  If you want such
       * semantics reliably you need SFTP v5 or better.
       */
      if(rename(oldpath, newpath) < 0)
        send_errno_status(job);
      else
        send_ok(job);
    } else
      send_errno_status(job);
  } else if(unlink(oldpath) < 0) {
    send_errno_status(job);
    unlink(newpath);
  } else
    send_ok(job);
}

void sftp_symlink(struct sftpjob *job) {
  char *oldpath, *newpath;

  pcheck(parse_path(job, &oldpath));
  pcheck(parse_path(job, &newpath));
  D(("sftp_symlink %s %s", oldpath, newpath));
  if(symlink(oldpath, newpath) < 0) send_errno_status(job);
  else send_ok(job);
  /* v3-v5 don't specify what happens if the target exists.  We take whatever
   * the OS gives us. */
}

void sftp_readlink(struct sftpjob *job) {
  char *path;
  char *result;
  int n;
  size_t nresult;
  struct namedata nd;

  pcheck(parse_path(job, &path));
  D(("sftp_readlink %s", path));
  /* readlink(2) has a rather stupid interface */
  nresult = 256;
  while(nresult > 0 && nresult <= 65536) {
    result = alloc(job->a, nresult);
    n = readlink(path, result, nresult);
    if(n < 0) {
      send_errno_status(job);
      return;
    }
    if((unsigned)n < nresult) {
      /* 1-element name list */
      path[n] = 0;
      memset(&nd, 0, sizeof nd);
      nd.path = path;
      nd.dummy = 1;
      send_begin(job);
      send_uint8(job, SSH_FXP_NAME);
      send_uint32(job, job->id);
      protocol->sendnames(job, 1, &nd);
      send_end(job);
      return;
    }
    nresult *= 2;
  }
  /* We should have wasted at most about 128Kbyte if we get here */
  protocol->status(job, SSH_FX_FAILURE, "link name is too long");
}

void sftp_opendir(struct sftpjob *job) {
  char *path;
  DIR *dp;
  struct handleid id;

  pcheck(parse_path(job, &path));
  D(("sftp_opendir %s", path));
  if(!(dp = opendir(path))) {
    send_errno_status(job);
    return;
  }
  handle_new_dir(&id, dp, path);
  D(("...handle is %"PRIu32" %"PRIu32, id.id, id.tag));
  send_begin(job);
  send_uint8(job, SSH_FXP_HANDLE);
  send_uint32(job, job->id);
  send_handle(job, &id);
  send_end(job);
}

void sftp_readdir(struct sftpjob *job) {
  struct handleid id;
  DIR *dp;
  uint32_t rc;
  struct namedata d[MAXNAMES];
  int n;
  struct dirent *de;
  const char *path;
  char *fullpath;
  
  pcheck(parse_handle(job, &id));
  D(("sftp_readdir %"PRIu32" %"PRIu32, id.id, id.tag));
  if((rc = handle_get_dir(&id, &dp, &path))) {
    protocol->status(job, rc, "invalid directory handle");
    return;
  }
  memset(d, 0, sizeof d);
  for(n = 0; n < MAXNAMES;) {
    /* readdir() has a slightly shonky interface - a null return can mean EOF
     * or error, and there is no guarantee that errno is reset to 0 on EOF. */
    errno = 0;
    de = readdir(dp);
    if(!de)
      break;
    /* We include . and .. in the list - if the cliient doesn't like them it
     * can filter them out itself. */
    d[n].path = strcpy(alloc(job->a, strlen(de->d_name) + 1), de->d_name);
    /* We need the full path to be able to stat the file */
    fullpath = alloc(job->a, strlen(path) + strlen(d[n].path) + 2);
    strcpy(fullpath, path);
    strcat(fullpath, "/");
    strcat(fullpath, d[n].path);
    if(lstat(fullpath, &d[n].filestat)) {
      send_errno_status(job);
      return;
    }
    ++n;
  }
  
  if(errno) {
    send_errno_status(job);
    return;
  }
  if(n) {
    send_begin(job);
    send_uint8(job, SSH_FXP_NAME);
    send_uint32(job, job->id);
    protocol->sendnames(job, n, d);
    send_end(job);
  } else
    protocol->status(job, SSH_FX_EOF, "end of directory list");
}

void sftp_close(struct sftpjob *job) {
  struct handleid id;
  
  pcheck(parse_handle(job, &id));
  D(("sftp_close %"PRIu32" %"PRIu32, id.id, id.tag));
  protocol->status(job, handle_close(&id), "closing handle");
}

void sftp_v3_realpath(struct sftpjob *job) {
  char *path;
  struct namedata nd;

  pcheck(parse_path(job, &path));
  D(("sftp_realpath %s", path));
  memset(&nd, 0, sizeof nd);
  /* realpath() demands a buffer of PATH_MAX bytes.  PATH_MAX isn't actually
   * guaranteed to be a constant so we must allocate in dynamically.  We add a
   * bit of extra space as a guard against broken C libraries. */
  nd.path = alloc(job->a, PATH_MAX + 64);
  nd.dummy = 1;
  if(realpath(path, nd.path)) {
    D(("...real path is %s", nd.path));
    send_begin(job);
    send_uint8(job, SSH_FXP_NAME);
    send_uint32(job, job->id);
    protocol->sendnames(job, 1, &nd);
    send_end(job);
  } else
    send_errno_status(job);
}

/* Command code for the various _*STAT calls.  rc is the return value
 * from *stat() and SB is the buffer. */
static void sftp_v3_stat_core(struct sftpjob *job, int rc, 
                              const struct stat *sb) {
  if(!rc) {
    send_begin(job);
    send_uint8(job, SSH_FXP_ATTRS);
    send_uint32(job, job->id);
    protocol->sendattrs(job, sb, 0);
    send_end(job);
  } else
    send_errno_status(job);
}

void sftp_v3_lstat(struct sftpjob *job) {
  char *path;
  struct stat sb;

  pcheck(parse_path(job, &path));
  D(("sftp_lstat %s", path));
  sftp_v3_stat_core(job, lstat(path, &sb), &sb);
}

void sftp_v3_stat(struct sftpjob *job) {
  char *path;
  struct stat sb;

  pcheck(parse_path(job, &path));
  D(("sftp_stat %s", path));
  sftp_v3_stat_core(job, stat(path, &sb), &sb);
}

void sftp_v3_fstat(struct sftpjob *job) {
  int fd;
  struct handleid id;
  struct stat sb;
  uint32_t rc;

  pcheck(parse_handle(job, &id));
  D(("sftp_fstat %"PRIu32" %"PRIu32, id.id, id.tag));
  if((rc = handle_get_fd(&id, &fd, 0))) {
    protocol->status(job, rc, "invalid file handle");
    return;
  }
  sftp_v3_stat_core(job, fstat(fd, &sb), &sb);
}

static int set_status(struct sftpjob *job,
                      const char *path,
                      const struct stat *sb,
                      unsigned long bits) {
  uid_t uid;
  gid_t gid;
  struct timeval times[2];
  struct stat current;

  if(bits & ATTR_SIZE) {
    D(("...truncate %s to %ju", path, (uintmax_t)sb->st_size));
    if(truncate(path, sb->st_size) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  uid = (bits & ATTR_UID) ? sb->st_uid : (uid_t)-1;
  gid = (bits & ATTR_GID) ? sb->st_gid : (gid_t)-1;
  if(uid != (uid_t)-1 || gid != (gid_t)-1) {
    D(("...lchown %s to %jd/%jd", path, (intmax_t)uid, (intmax_t)gid));
    if(lchown(path, uid, gid) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  if(bits & ATTR_PERMISSIONS) {
    D(("...chmod %s to %#o", path, (unsigned)sb->st_mode & 0777));
    if(chmod(path, sb->st_mode & 0777) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  if(bits & (ATTR_MTIME|ATTR_ATIME)) {
    if(lstat(path, &current) < 0) {
      D(("cannot lstat %s", path));
      send_errno_status(job);
      return -1;
    }
    times[0].tv_sec = (bits & ATTR_ATIME) ? sb->st_atime : current.st_atime;
    times[1].tv_sec = (bits & ATTR_MTIME) ? sb->st_mtime : current.st_mtime;
#if HAVE_STAT_TIMESPEC
    times[0].tv_usec = ((bits & ATTR_ATIME) 
                        ? sb->st_atimespec.tv_nsec
                        : current.st_atimespec.tv_nsec) / 1000;
    times[1].tv_usec = ((bits & ATTR_MTIME)
                        ? sb->st_mtimespec.tv_nsec
                        : current.st_mtimespec.tv_nsec) / 1000;
#endif
    D(("...utimes %s to atime %lu.%06lu mtime %lu.%06lu", path,
       (unsigned long)times[0].tv_sec, (unsigned long)times[0].tv_usec,
       (unsigned long)times[1].tv_sec, (unsigned long)times[1].tv_usec));
    if(utimes(path, times) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  return 0;
}

static int set_fstatus(struct sftpjob *job,
                       int fd,
                       const struct stat *sb,
                       unsigned long bits) {
  uid_t uid;
  gid_t gid;
  struct timeval times[2];
  struct stat current;

  if(bits & ATTR_SIZE) {
    D(("...truncate %ju", (uintmax_t)sb->st_size));
    if(ftruncate(fd, sb->st_size) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  uid = (bits & ATTR_UID) ? sb->st_uid : (uid_t)-1;
  gid = (bits & ATTR_GID) ? sb->st_gid : (gid_t)-1;
  if(uid != (uid_t)-1 || gid != (gid_t)-1) {
    D(("...fchown %jd/%jd", (intmax_t)uid, (intmax_t)gid));
    if(fchown(fd, uid, gid) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  if(bits & ATTR_PERMISSIONS) {
    D(("...fchmod %#o", (unsigned)sb->st_mode & 0777));
    if(fchmod(fd, sb->st_mode & 0777) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  if(bits & (ATTR_MTIME|ATTR_ATIME)) {
    if(fstat(fd, &current) < 0) {
      D(("cannot fstat"));
      send_errno_status(job);
      return -1;
    }
    times[0].tv_sec = (bits & ATTR_ATIME) ? sb->st_atime : current.st_atime;
    times[1].tv_sec = (bits & ATTR_MTIME) ? sb->st_mtime : current.st_mtime;
#if HAVE_STAT_TIMESPEC
    times[0].tv_usec = ((bits & ATTR_ATIME) 
                        ? sb->st_atimespec.tv_nsec
                        : current.st_atimespec.tv_nsec) / 1000;
    times[1].tv_usec = ((bits & ATTR_MTIME)
                        ? sb->st_mtimespec.tv_nsec
                        : current.st_mtimespec.tv_nsec) / 1000;
#endif
    D(("...utimes atime %lu.%06lu mtime %lu.%06lu",
       (unsigned long)times[0].tv_sec, (unsigned long)times[0].tv_usec,
       (unsigned long)times[1].tv_sec, (unsigned long)times[1].tv_usec));
    if(futimes(fd, times) < 0) {
      send_errno_status(job);
      return -1;
    }
  }
  return 0;
}

void sftp_setstat(struct sftpjob *job) {
  char *path;
  struct stat sb;
  unsigned long bits;

  pcheck(parse_path(job, &path));
  pcheck(protocol->parseattrs(job, &sb, &bits));
  D(("sftp_setstat %s", path));
  if(set_status(job, path, &sb, bits))   /* sends error itself */
    return;
  send_ok(job);                         /* but we must send the OK */
}

void sftp_fsetstat(struct sftpjob *job) {
  struct handleid id;
  struct stat sb;
  unsigned long bits;
  int fd;
  uint32_t rc;

  pcheck(parse_handle(job, &id));
  pcheck(protocol->parseattrs(job, &sb, &bits));
  D(("sftp_fsetstat %"PRIu32" %"PRIu32, id.id, id.tag));
  if((rc = handle_get_fd(&id, &fd, 0))) {
    protocol->status(job, rc, "invalid file handle");
    return;
  }
  if(set_fstatus(job, fd, &sb, bits))   /* sends error itself */
    return;
  send_ok(job);                         /* but we must send the OK */
}

void sftp_mkdir(struct sftpjob *job) {
  char *path;
  struct stat sb;
  unsigned long bits;

  pcheck(parse_path(job, &path));
  pcheck(protocol->parseattrs(job, &sb, &bits));
  D(("sftp_mkdir %s", path));
  bits &= ~ATTR_SIZE;                   /* makes no sense */
  if((bits & ATTR_PERMISSIONS)) {
    /* If we're given initial permissions, use them and don't reset them  */
    if(mkdir(path, sb.st_mode & 0777) < 0) {
      send_errno_status(job);
      return;
    }
    bits &= ~ATTR_PERMISSIONS;
  } else {
    /* Otherwise follow the current umask */
    if(mkdir(path, 0777) < 0) {
      send_errno_status(job);
      return;
    }
  }
  if(set_status(job, path, &sb, bits)) {
    /* If we can't have the desired permissions, don't have the directory at
     * all */
    rmdir(path);
    return;
  }
  send_ok(job);
}

void sftp_v3_open(struct sftpjob *job) {
  char *path;
  uint32_t pflags;
  struct stat sb;
  unsigned long bits;
  int open_flags, fd;
  struct handleid id;

  pcheck(parse_path(job, &path));
  pcheck(parse_uint32(job, &pflags));
  pcheck(protocol->parseattrs(job, &sb, &bits));
  D(("sftp_open %s %#"PRIx32, path, pflags));
  /* Translate pflags to open(2) format */
  switch(pflags & (SSH_FXF_READ|SSH_FXF_WRITE)) {
  case SSH_FXF_READ:
    open_flags = O_RDONLY;
    break;
  case SSH_FXF_WRITE:
    open_flags = O_WRONLY;
    break;
  case SSH_FXF_READ|SSH_FXF_WRITE:
    open_flags = O_RDWR;
    break;
  default:
    protocol->status(job, SSH_FX_BAD_MESSAGE,
                     "need SSH_FXF_READ or SSH_FXF_WRITE");
    return;
  }
  /* Append only makes sense for writable files */
  if(pflags & SSH_FXF_WRITE)
    if(pflags & SSH_FXF_APPEND)
      open_flags |= O_APPEND;
  if(pflags & SSH_FXF_CREAT) {
    open_flags |= O_CREAT;
    /* Truncate and no-overwrite only make sense if creating */
    if(pflags & SSH_FXF_TRUNC) open_flags |= O_TRUNC;
    if(pflags & SSH_FXF_EXCL) open_flags |= O_EXCL;
  }
  if((bits & ATTR_PERMISSIONS)) {
    /* If we're given initial permissions, use them and don't reset them  */
    if((fd = open(path, open_flags, sb.st_mode & 0777)) < 0) {
      send_errno_status(job);
      return;
    }
    bits &= ~ATTR_PERMISSIONS;
  } else {
    /* Otherwise follow the current umask */
    if((fd = open(path, open_flags, 0777)) < 0) {
      send_errno_status(job);
      return;
    }
  }
  if(set_fstatus(job, fd, &sb, bits)) {
    /* If we can't have the desired permissions, don't have the directory at
     * all */
    close(fd);
    unlink(path);
    return;                             /* already sent error */
  }
  handle_new_file(&id, fd, path);
  D(("...handle is %"PRIu32" %"PRIu32, id.id, id.tag));
  send_begin(job);
  send_uint8(job, SSH_FXP_HANDLE);
  send_uint32(job, job->id);
  send_handle(job, &id);
  send_end(job);
}

void sftp_read(struct sftpjob *job) {
  struct handleid id;
  uint64_t offset;
  uint32_t len, rc;
  char *buffer;
  ssize_t n;
  int fd;

  pcheck(parse_handle(job, &id));
  pcheck(parse_uint64(job, &offset));
  pcheck(parse_uint32(job, &len));
  D(("sftp_read %"PRIu32" %"PRIu32": %"PRIu32" bytes at %"PRIu64,
     id.id, id.tag, len, offset));
  if(len > MAXREAD) len = MAXREAD;
  if((rc = handle_get_fd(&id, &fd, 0))) {
    protocol->status(job, rc, "invalid file handle");
    return;
  }
  buffer = alloc(job->a, len);
  n = pread(fd, buffer, len, offset);
  /* Short reads are allowed so we don't try to read more */
  if(n > 0) {
    send_begin(job);
    send_uint8(job, SSH_FXP_DATA);
    send_uint32(job, job->id);
    send_bytes(job, buffer, n);
    send_end(job);
  } else if(n == 0)
    protocol->status(job, SSH_FX_EOF, 0);
  else
    send_errno_status(job);
}

void sftp_write(struct sftpjob *job) {
  struct handleid id;
  uint64_t offset;
  uint32_t len, rc;
  ssize_t n;
  int fd;

  pcheck(parse_handle(job, &id));
  pcheck(parse_uint64(job, &offset));
  pcheck(parse_uint32(job, &len));
  if(len > job->left) {
    protocol->status(job, SSH_FX_BAD_MESSAGE, "truncated SSH_FXP_WRITE");
    return;
  }
  D(("sftp_write %"PRIu32" %"PRIu32": %"PRIu32" bytes at %"PRIu64,
     id.id, id.tag, len, offset));
  if((rc = handle_get_fd(&id, &fd, 0))) {
    protocol->status(job, rc, "invalid file handle");
    return;
  }
  while(len > 0) {
    /* Short writes aren't allowed so we loop around writing more */
    n = pwrite(fd, job->ptr, len, offset);
    if(n < 0) {
      send_errno_status(job);
      return;
    }
    job->ptr += n;
    job->left += n;
    len -= n;
    offset -= n;
  }
  send_ok(job);
}

static const struct sftpcmd sftpv3tab[] = {
  { SSH_FXP_INIT, sftp_already_init },
  { SSH_FXP_OPEN, sftp_v3_open },
  { SSH_FXP_CLOSE, sftp_close },
  { SSH_FXP_READ, sftp_read },
  { SSH_FXP_WRITE, sftp_write },
  { SSH_FXP_LSTAT, sftp_v3_lstat },
  { SSH_FXP_FSTAT, sftp_v3_fstat },
  { SSH_FXP_SETSTAT, sftp_setstat },
  { SSH_FXP_FSETSTAT, sftp_fsetstat },
  { SSH_FXP_OPENDIR, sftp_opendir },
  { SSH_FXP_READDIR, sftp_readdir },
  { SSH_FXP_REMOVE, sftp_remove },
  { SSH_FXP_MKDIR, sftp_mkdir },
  { SSH_FXP_RMDIR, sftp_rmdir },
  { SSH_FXP_REALPATH, sftp_v3_realpath },
  { SSH_FXP_STAT, sftp_v3_stat },
  { SSH_FXP_RENAME, sftp_v3_rename },
  { SSH_FXP_READLINK, sftp_readlink },
  { SSH_FXP_SYMLINK, sftp_symlink },
  //{ SSH_FXP_EXTENDED, sftp_extended },
};

const struct sftpprotocol sftpv3 = {
  sizeof sftpv3tab / sizeof (struct sftpcmd),
  sftpv3tab,
  v3_status,
  v3_sendnames,
  v3_sendattrs,
  v3_parseattrs,
  v3_encode,
  v3_decode
};

/*
Local Variables:
c-basic-offset:2
comment-column:40
fill-column:79
indent-tabs-mode:nil
End:
*/
